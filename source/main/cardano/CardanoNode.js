// @flow
import { createWriteStream, readFileSync } from 'fs';
import { spawn } from 'child_process';
import type { ChildProcess } from 'child_process';
import type { WriteStream } from 'fs';
import type { TlsConfig } from '../../common/ipc-api/tls-config';
import { promisedCondition } from './utils';

type NodeArgs = Array<string>;

type Logger = {
  debug: (string) => void,
  info: (string) => void,
  error: (string) => void,
};

type Actions = {
  sendTlsConfig: (TlsConfig) => void,
  onStopped: (code: number, signal: string) => void,
  onUpdated: (code: number, signal: string) => void,
  onCrashed: (code: number, signal: string) => void,
};

type NodeIpcMessage = {
  Started?: Array<any>,
  ReplyPort?: number,
}

type CardanoNodeConfig = {
  nodePath: string, // Path to cardano-node executable
  tlsPath: string, // Path to cardano-node TLS folder
  nodeArgs: NodeArgs, // Arguments that are used to spwan cardano-node
  logFilePath: string, // Path to log file that is used to write the stdio of cardano-node
  startupTimeout: number, // Milliseconds to wait for cardano-node to startup
  shutdownTimeout: number, // Milliseconds to wait for cardano-node to gracefully shutdown
  killTimeout: number, // Milliseconds to wait for cardano-node to be killed
  updateTimeout: number, // Milliseconds to wait for cardano-node to update itself
}

type CardanoNodeState = (
  'stopped' | 'starting' | 'running' | 'stopping' | 'updating' | 'updated' | 'crashed'
);

export class CardanoNode {
  /**
   * The config used to spawn cardano-node
   * @private
   */
  config: CardanoNodeConfig;
  /**
   * The managed cardano-node child process
   * @private
   */
  node: ChildProcess;

  /**
   * The ipc channel used for broadcasting messages to the outside world
   * @private
   */
  actions: Actions;
  /**
   * Logger instance to print debug messages to
   * @private
   */
  log: Logger;

  cardanoLogFile: WriteStream;

  /**
   * The TLS config that is generated by the cardano-node
   * on each startup and is broadcasted over ipc channel
   * @private
   */
  _tlsConfig: TlsConfig = {
    ca: null,
    key: null,
    cert: null,
    port: null,
  };

  static STARTING: CardanoNodeState = 'starting';
  static RUNNING: CardanoNodeState = 'running';
  static STOPPING: CardanoNodeState = 'stopping';
  static STOPPED: CardanoNodeState = 'stopped';
  static UPDATING: CardanoNodeState = 'updating';
  static UPDATED: CardanoNodeState = 'updated';
  static CRASHED: CardanoNodeState = 'crashed';
  state: CardanoNodeState = CardanoNode.STOPPED;

  constructor(config: CardanoNodeConfig, log: Logger, actions: Actions) {
    this.config = config;
    this.log = log;
    this.actions = actions;
    this._resetTlsConfig();
  }

  start() {
    const { log } = this;
    const { nodePath, nodeArgs, logFilePath, startupTimeout } = this.config;
    if (this.state !== CardanoNode.STOPPED) return;
    const logFile = createWriteStream(logFilePath, { flags: 'a' });
    logFile.on('open', async () => {
      this.cardanoLogFile = logFile;
      // Spawning cardano-node
      const jsonArgs = JSON.stringify(nodeArgs);
      log.info(`Spawning cardano-node from path: ${nodePath} with args: ${jsonArgs}.`);
      const node = this._spawnNode(nodePath, nodeArgs, logFile);
      this.node = node;
      try {
        await promisedCondition(() => node.connected, startupTimeout);
        // Setup livecycle event handlers
        node.on('message', this._handleCardanoNodeMessage);
        node.on('disconnect', this._handleCardanoNodeDisconnect);
        node.on('exit', this._handleCardanoNodeExit);
        node.on('error', this._handleCardanoNodeError);

        // Request cardano-node to reply with port
        node.send({ QueryPort: [] });
        log.info(`cardano-node child process spawned with PID ${node.pid}`);
        this._changeToState(CardanoNode.STARTING);
      } catch (_) {
        throw new Error('Error while spawning cardano-node.');
      }
    });
  }

  stop(): Promise<?number> {
    const { node, log, config } = this;
    if (this.state !== CardanoNode.RUNNING) {
      return Promise.reject('CardanoNode is not running.');
    }
    return new Promise(async (resolve, reject) => {
      log.info('CardanoNode: disconnecting from cardano-node process.');
      try {
        node.disconnect();
        this._changeToState(CardanoNode.STOPPING);
        await promisedCondition(
          () => this.state === CardanoNode.STOPPED,
          config.shutdownTimeout
        );
        resolve();
      } catch (e) {
        log.info('CardanoNode: cardano-node did not shut itself down correctly.');
        try {
          return this.kill();
        } catch (killError) {
          reject(killError);
        }
      }
    });
  }

  kill(): Promise<?number> {
    const { node, log, config } = this;
    return new Promise(async (resolve, reject) => {
      try {
        log.info('CardanoNode: killing cardano-node process.');
        node.kill();
        await promisedCondition(
          () => this.state === CardanoNode.STOPPED,
          config.killTimeout
        );
        resolve();
      } catch (_) {
        log.info('CardanoNode: could not kill cardano-node.');
        reject('Could not kill cardano-node.');
      }
    });
  }

  broadcastTlsConfig() {
    this.actions.sendTlsConfig(this._tlsConfig);
  }

  get tlsConfig(): TlsConfig {
    return Object.assign({}, this._tlsConfig);
  }

  get pid(): number {
    return this.node.pid;
  }

  handleNodeUpdate(): Promise<void> {
    const { log, config } = this;
    this.state = CardanoNode.UPDATING;
    return new Promise(async (resolve, reject) => {
      try {
        log.info('CardanoNode: waiting for node to apply update.');
        await promisedCondition(
          () => this.state === CardanoNode.UPDATED,
          config.shutdownTimeout
        );
        resolve();
      } catch (stopError) {
        log.info('CardanoNode: did not apply update correctly. Killing it.');
        try {
          await this.kill();
        } catch (_) {
          reject();
        }
      }
    });
  }

  // =============== PRIVATE ===================

  /**
   * Spawns cardano-node as child_process in ipc mode
   * @param nodePath {string}
   * @param args {NodeArgs}
   * @param logFile {WriteStream}
   * @returns {ChildProcess}
   * @private
   */
  _spawnNode(nodePath: string, args: NodeArgs, logFile: WriteStream) {
    return spawn(nodePath, args, { stdio: ['inherit', logFile, logFile, 'ipc'] });
  }

  _handleCardanoNodeMessage = (msg: NodeIpcMessage) => {
    const { log, _tlsConfig } = this;
    const { tlsPath } = this.config;
    log.info(`CardanoNode: received message: ${JSON.stringify(msg)}`);
    if (msg.Started) {
      log.info('CardanoNode: started, TLS certs updated');
      Object.assign(_tlsConfig, {
        ca: readFileSync(tlsPath + '/client/ca.crt'),
        key: readFileSync(tlsPath + '/client/client.key'),
        cert: readFileSync(tlsPath + '/client/client.pem'),
      });
    } else if (msg.ReplyPort) {
      _tlsConfig.port = msg.ReplyPort;
    }
    if (this.state === CardanoNode.STARTING && this._isTlsConfigComplete()) {
      this._changeToState(CardanoNode.RUNNING);
      this.broadcastTlsConfig();
    }
  };

  _handleCardanoNodeError = (error: Error) => {
    const { log } = this;
    log.info(`CardanoNode: error: ${error.toString()}`);
    // TODO: handle error cases
    this._reset();
  };

  _handleCardanoNodeDisconnect = () => {
    const { log } = this;
    log.info('CardanoNode: disconnected from cardano-node.');
    if (this.state !== CardanoNode.STOPPING) {
      // TODO: Disconnect was not expected -> do something
    }
    this._reset();
  };

  _handleCardanoNodeExit = (code: number, signal: string) => {
    const { log, actions } = this;
    log.info(`CardanoNode: cardano-node exited with: ${code}, ${signal}`);
    if (this.state === CardanoNode.STOPPING) {
      this._changeToState(CardanoNode.STOPPED);
      actions.onStopped(code, signal);
    } else if (this.state === CardanoNode.UPDATING) {
      this._changeToState(CardanoNode.UPDATED);
      actions.onUpdated(code, signal);
    } else if (!this.state === CardanoNode.UPDATED) {
      this._changeToState(CardanoNode.CRASHED);
      actions.onCrashed(code, signal);
    }
    this._reset();
  };

  _resetTlsConfig = () => {
    Object.assign(this._tlsConfig, {
      ca: null,
      key: null,
      cert: null,
      port: null,
    });
  };

  _reset = () => {
    if (this.cardanoLogFile) this.cardanoLogFile.end();
    this._resetTlsConfig();
  };

  _isTlsConfigComplete = () => {
    const { ca, key, cert, port } = this._tlsConfig;
    return ca != null && key != null && cert != null && port != null;
  };

  _changeToState(state: CardanoNodeState) {
    const { log } = this;
    log.info(`CardanoNode: changing state to "${state}"`);
    this.state = state;
  }

}
