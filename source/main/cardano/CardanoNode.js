// @flow
import { readFileSync } from 'fs';
import { spawn } from 'child_process';
import type { ChildProcess } from 'child_process';
import type { WriteStream } from 'fs';
import type { TlsConfig } from '../../common/ipc-api/tls-config';

type NodeArgs = Array<string>;

type Logger = {
  debug: (string) => void,
  info: (string) => void,
  error: (string) => void,
};

type IpcChannels = {
  sendTlsConfig: (TlsConfig) => void,
};

type NodeIpcMessage = {
  Started?: Array<any>,
  ReplyPort?: number,
}

type CardanoNodeConfig = {
  nodePath: string, // Path to cardano-node executable
  tlsPath: string, // Path to cardano-node TLS folder
  nodeArgs: NodeArgs, // Arguments that are used to spwan cardano-node
  logFile: WriteStream, // Logfile that is used to write the stdio of cardano-node to
}

export class CardanoNode {
  /**
   * The config used to spawn cardano-node
   * @private
   */
  config: CardanoNodeConfig;
  /**
   * The managed cardano-node child process
   * @private
   */
  node: ChildProcess;

  /**
   * The ipc channel used for broadcasting messages to the outside world
   * @private
   */
  ipcChannels: IpcChannels;
  /**
   * Logger instance to print debug messages to
   * @private
   */
  log: Logger;

  /**
   * The TLS config that is generated by the cardano-node
   * on each startup and is broadcasted over ipc channel
   * @private
   */
  tlsConfig: TlsConfig = {
    ca: null,
    key: null,
    cert: null,
    port: null,
  };

  constructor(config: CardanoNodeConfig, log: Logger, ipcChannels: IpcChannels) {
    this.config = config;
    this.log = log;
    this.ipcChannels = ipcChannels;
  }

  start() {
    const { log } = this;
    const { nodePath, nodeArgs, logFile } = this.config;
    logFile.on('open', () => {

      // Spawning cardano-node
      const jsonArgs = JSON.stringify(nodeArgs);
      log.info(`Spawning cardano-node from path: ${nodePath} with args: ${jsonArgs}.`);
      this.node = this._spawnNode(nodePath, nodeArgs, logFile);
      log.info('CardanoNode spawned.');

      this.node.on('message', this._handleCardanoNodeMessage);

      this.node.on('close', (code, signal) => {
        log.info(`CardanoNode: all stdio to child has been closed with: ${code}, ${signal}`);
      });

      this.node.on('disconnect', () => {
        log.info('CardanoNode: all IPC handles closed');
      });

      this.node.on('error', (err) => {
        log.info(`CardanoNode: error: ${err}`);
      });

      this.node.on('exit', (code, signal) => {
        // TODO: give a better UI when it fails and auto-retry a few times
        log.info(`CardanoNode: child exited with ${code}, ${signal}`);
      });

      this.node.send({ QueryPort: [] });
    });
  }

  stop() {
    const { node, log } = this;
    if (node) {
      log.info('CardanoNode: disconnecting IPC channel');
      node.disconnect();
    }
  }

  broadcastTlsConfig() {
    this.ipcChannels.sendTlsConfig(this.tlsConfig);
  }

  get pid(): number {
    return this.node.pid;
  }

  // =============== PRIVATE ===================

  /**
   * Spawns cardano-node as child_process in ipc mode
   * @param nodePath {string}
   * @param args {NodeArgs}
   * @param logFile {WriteStream}
   * @returns {ChildProcess}
   * @private
   */
  _spawnNode(nodePath: string, args: NodeArgs, logFile: WriteStream) {
    return spawn(nodePath, args, { stdio: ['inherit', logFile, logFile, 'ipc'] });
  }

  _handleCardanoNodeMessage = (msg: NodeIpcMessage) => {
    const { log } = this;
    const { tlsPath } = this.config;
    log.info(`CardanoNode: received message: ${JSON.stringify(msg)}`);
    if (msg.Started) {
      log.info('CardanoNode: started, TLS certs updated');
      Object.assign(this.tlsConfig, {
        ca: readFileSync(tlsPath + '/client/ca.crt'),
        key: readFileSync(tlsPath + '/client/client.key'),
        cert: readFileSync(tlsPath + '/client/client.pem'),
      });
    } else if (msg.ReplyPort) {
      this.tlsConfig.port = msg.ReplyPort;
      this.broadcastTlsConfig();
    }
  }

}
