// @flow
import { createWriteStream, readFileSync } from 'fs';
import { spawn } from 'child_process';
import type { ChildProcess } from 'child_process';
import type { WriteStream } from 'fs';
import type { TlsConfig } from '../../common/ipc-api/tls-config';
import { promisedCondition } from './utils';
import type { CardanoNodeState } from '../../common/types/cardanoNodeTypes';

type NodeArgs = Array<string>;

type Logger = {
  debug: (string) => void,
  info: (string) => void,
  error: (string) => void,
};

type Actions = {
  broadcastTlsConfig: (TlsConfig) => void,
  broadcastStateChange: (state: CardanoNodeState) => void,
};

type Transitions = {
  onStarting: () => void,
  onRunning: () => void,
  onStopping: () => void,
  onStopped: () => void,
  onUpdating: () => void,
  onUpdated: () => void,
  onCrashed: (code: number, signal: string) => void,
}

type NodeIpcMessage = {
  Started?: Array<any>,
  ReplyPort?: number,
}

type CardanoNodeConfig = {
  nodePath: string, // Path to cardano-node executable
  tlsPath: string, // Path to cardano-node TLS folder
  nodeArgs: NodeArgs, // Arguments that are used to spwan cardano-node
  logFilePath: string, // Path to log file that is used to write the stdio of cardano-node
  startupTimeout: number, // Milliseconds to wait for cardano-node to startup
  shutdownTimeout: number, // Milliseconds to wait for cardano-node to gracefully shutdown
  killTimeout: number, // Milliseconds to wait for cardano-node to be killed
  updateTimeout: number, // Milliseconds to wait for cardano-node to update itself
}

export class CardanoNode {
  /**
   * The config used to spawn cardano-node
   * @private
   */
  config: CardanoNodeConfig;
  /**
   * The managed cardano-node child process
   * @private
   */
  node: ChildProcess;

  /**
   * The ipc channel used for broadcasting messages to the outside world
   * @private
   */
  actions: Actions;

  /**
   * The ipc channel used for broadcasting messages to the outside world
   * @private
   */
  _transitions: Transitions;
  /**
   * Logger instance to print debug messages to
   * @private
   */
  log: Logger;

  cardanoLogFile: WriteStream;

  /**
   * The TLS config that is generated by the cardano-node
   * on each startup and is broadcasted over ipc channel
   * @private
   */
  _tlsConfig: TlsConfig = {
    ca: null,
    key: null,
    cert: null,
    port: null,
  };

  static STARTING: CardanoNodeState = 'starting';
  static RUNNING: CardanoNodeState = 'running';
  static STOPPING: CardanoNodeState = 'stopping';
  static STOPPED: CardanoNodeState = 'stopped';
  static UPDATING: CardanoNodeState = 'updating';
  static UPDATED: CardanoNodeState = 'updated';
  static CRASHED: CardanoNodeState = 'crashed';
  state: CardanoNodeState = CardanoNode.STOPPED;

  constructor(config: CardanoNodeConfig, log: Logger, actions: Actions, transitions: Transitions) {
    this.config = config;
    this.log = log;
    this.actions = actions;
    this._transitions = transitions;
    this._resetTlsConfig();
  }

  start() {
    const { log } = this;
    const { nodePath, nodeArgs, logFilePath, startupTimeout } = this.config;
    if (!this._canBeRestarted()) return;
    const logFile = createWriteStream(logFilePath, { flags: 'a' });
    logFile.on('open', async () => {
      this.cardanoLogFile = logFile;
      // Spawning cardano-node
      const jsonArgs = JSON.stringify(nodeArgs);
      log.info(`Spawning cardano-node from path: ${nodePath} with args: ${jsonArgs}.`);
      const node = this._spawnNode(nodePath, nodeArgs, logFile);
      this.node = node;
      try {
        await promisedCondition(() => node.connected, startupTimeout);
        // Setup livecycle event handlers
        node.on('message', this._handleCardanoNodeMessage);
        node.on('disconnect', this._handleCardanoNodeDisconnect);
        node.on('exit', this._handleCardanoNodeExit);
        node.on('error', this._handleCardanoNodeError);

        // Request cardano-node to reply with port
        node.send({ QueryPort: [] });
        log.info(`cardano-node child process spawned with PID ${node.pid}`);
        this._changeToState(CardanoNode.STARTING);
      } catch (_) {
        throw new Error('Error while spawning cardano-node.');
      }
    });
  }

  stop(): Promise<?number> {
    const { node, log, config } = this;
    if (!this._canBeStopped()) {
      return Promise.reject('CardanoNode is not running.');
    }
    return new Promise(async (resolve, reject) => {
      log.info('CardanoNode: disconnecting from cardano-node process.');
      try {
        node.disconnect();
        this._changeToState(CardanoNode.STOPPING);
        await promisedCondition(
          () => this.state === CardanoNode.STOPPED,
          config.shutdownTimeout
        );
        resolve();
      } catch (e) {
        log.info('CardanoNode: cardano-node did not shut itself down correctly.');
        try {
          return this.kill();
        } catch (killError) {
          reject(killError);
        }
      }
    });
  }

  kill(): Promise<?number> {
    const { node, log, config } = this;
    return new Promise(async (resolve, reject) => {
      try {
        log.info('CardanoNode: killing cardano-node process.');
        node.kill();
        await promisedCondition(
          () => this.state === CardanoNode.STOPPED,
          config.killTimeout
        );
        resolve();
      } catch (_) {
        log.info('CardanoNode: could not kill cardano-node.');
        reject('Could not kill cardano-node.');
      }
    });
  }

  broadcastTlsConfig() {
    this.actions.broadcastTlsConfig(this._tlsConfig);
  }

  get tlsConfig(): TlsConfig {
    return Object.assign({}, this._tlsConfig);
  }

  get pid(): number {
    return this.node.pid;
  }

  handleNodeUpdate(): Promise<void> {
    const { log, config } = this;
    this._changeToState(CardanoNode.UPDATING);
    return new Promise(async (resolve, reject) => {
      try {
        log.info('CardanoNode: waiting for node to apply update.');
        await promisedCondition(
          () => this.state === CardanoNode.UPDATED,
          config.updateTimeout
        );
        resolve();
      } catch (stopError) {
        log.info('CardanoNode: did not apply update correctly. Killing it.');
        try {
          await this.kill();
        } catch (_) {
          reject();
        }
      }
    });
  }

  // =============== PRIVATE ===================

  /**
   * Spawns cardano-node as child_process in ipc mode
   * @param nodePath {string}
   * @param args {NodeArgs}
   * @param logFile {WriteStream}
   * @returns {ChildProcess}
   * @private
   */
  _spawnNode(nodePath: string, args: NodeArgs, logFile: WriteStream) {
    return spawn(nodePath, args, { stdio: ['inherit', logFile, logFile, 'ipc'] });
  }

  _handleCardanoNodeMessage = (msg: NodeIpcMessage) => {
    const { log, _tlsConfig } = this;
    const { tlsPath } = this.config;
    log.info(`CardanoNode: received message: ${JSON.stringify(msg)}`);
    if (msg.Started) {
      log.info('CardanoNode: started, TLS certs updated');
      Object.assign(_tlsConfig, {
        ca: readFileSync(tlsPath + '/client/ca.crt'),
        key: readFileSync(tlsPath + '/client/client.key'),
        cert: readFileSync(tlsPath + '/client/client.pem'),
      });
    } else if (msg.ReplyPort) {
      _tlsConfig.port = msg.ReplyPort;
    }
    if (this.state === CardanoNode.STARTING && this._isTlsConfigComplete()) {
      this._changeToState(CardanoNode.RUNNING);
      this.broadcastTlsConfig();
    }
  };

  _handleCardanoNodeError = (error: Error) => {
    const { log } = this;
    log.info(`CardanoNode: error: ${error.toString()}`);
    // TODO: handle error cases
    this._reset();
  };

  _handleCardanoNodeDisconnect = () => {
    const { log } = this;
    log.info('CardanoNode: disconnected from cardano-node.');
    if (this.state !== CardanoNode.STOPPING) {
      // TODO: Disconnect was not expected -> do something
    }
    this._reset();
  };

  _handleCardanoNodeExit = (code: number, signal: string) => {
    const { log } = this;
    log.info(`CardanoNode: cardano-node exited with: ${code}, ${signal}`);
    if (this.state === CardanoNode.STOPPING) {
      this._changeToState(CardanoNode.STOPPED);
    } else if (this.state === CardanoNode.UPDATING) {
      this._changeToState(CardanoNode.UPDATED);
    } else if (this.state !== CardanoNode.UPDATED) {
      this._changeToState(CardanoNode.CRASHED, code, signal);
    }
    this._reset();
  };

  _resetTlsConfig = () => {
    Object.assign(this._tlsConfig, {
      ca: null,
      key: null,
      cert: null,
      port: null,
    });
  };

  _reset = () => {
    if (this.cardanoLogFile) this.cardanoLogFile.end();
    this._resetTlsConfig();
  };

  _isTlsConfigComplete = () => {
    const { ca, key, cert, port } = this._tlsConfig;
    return ca != null && key != null && cert != null && port != null;
  };

  _changeToState(state: CardanoNodeState, ...args: Array<any>) {
    const { log, _transitions } = this;
    log.info(`CardanoNode: transitions to "${state}"`);
    this.state = state;
    this.actions.broadcastStateChange(state);
    switch (state) {
      case CardanoNode.STARTING: return _transitions.onStarting();
      case CardanoNode.RUNNING: return _transitions.onRunning();
      case CardanoNode.STOPPING: return _transitions.onStopping();
      case CardanoNode.STOPPED: return _transitions.onStopped();
      case CardanoNode.UPDATING: return _transitions.onUpdating();
      case CardanoNode.UPDATED: return _transitions.onUpdated();
      case CardanoNode.CRASHED: return _transitions.onCrashed(...args);
      default:
    }
  }

  _canBeRestarted = () => (
    this.state === CardanoNode.STOPPED ||
    this.state === CardanoNode.UPDATED ||
    this.state === CardanoNode.CRASHED
  );

  _canBeStopped = () => (
    this.state === CardanoNode.STARTING ||
    this.state === CardanoNode.RUNNING
  );

}
